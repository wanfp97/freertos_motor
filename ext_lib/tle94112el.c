/*********************************************************************************************************************
 * Copyright (c) 2018-2020, Infineon Technologies AG
 * All rights reserved.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * To improve the quality of the software, users are encouraged to share
 * modifications, enhancements or bug fixes with Infineon Technologies AG
 * at XMCSupport@infineon.com.
 *********************************************************************************************************************/

#include "tle94112el.h"

#define TLE94112EL_SPI_WRITE        0x80
#define TLE94112EL_SPI_CLEAR        0x80

#define TLE94112EL_PWM_CH_FREQ_CTRL_PWM_CH_FREQ_Msk		TLE94112EL_PWM_CH_FREQ_CTRL_PWM_CH1_FREQ_Msk
#define TLE94112EL_PWM_CH_FREQ_CTRL_PWM_CH_FREQ_Size    (TLE94112EL_PWM_CH_FREQ_CTRL_PWM_CH2_FREQ_Pos - TLE94112EL_PWM_CH_FREQ_CTRL_PWM_CH1_FREQ_Pos)
#define TLE94112EL_HB_MODE_CTRL_HB_MODE_Msk  			TLE94112EL_HB_MODE_1_CTRL_HB1_MODE_Msk
#define TLE94112EL_HB_MODE_CTRL_HB_MODE_Size 			(TLE94112EL_HB_MODE_1_CTRL_HB2_MODE_Pos - TLE94112EL_HB_MODE_1_CTRL_HB1_MODE_Pos)
#define TLE94112EL_HB_ACT_CTRL_HB_Msk                   (TLE94112EL_HB_ACT_1_CTRL_HB1_HS_EN_Msk | TLE94112EL_HB_ACT_1_CTRL_HB1_LS_EN_Msk)
#define TLE94112EL_HB_ACT_CTRL_HB_Size                  (TLE94112EL_HB_ACT_1_CTRL_HB2_LS_EN_Pos - TLE94112EL_HB_ACT_1_CTRL_HB1_LS_EN_Pos)

static inline uint8_t get_pwm_channel_dc_address(uint8_t channel)
{
  switch (channel)
  {
    case TLE94112EL_PWM_CHANNEL_1:
      return TLE94112EL_PWM1_DC_CTRL;

    case TLE94112EL_PWM_CHANNEL_2:
      return TLE94112EL_PWM2_DC_CTRL;

    case TLE94112EL_PWM_CHANNEL_3:
      return TLE94112EL_PWM3_DC_CTRL;

    default:
      return 0xff;
  }
}

static inline uint8_t get_hbridge_mode_address(uint8_t hbridge)
{
  if (hbridge < TLE94112EL_HBRIDGE_5)
  {
    return TLE94112EL_HB_MODE_1_CTRL;
  }
  else if (hbridge < TLE94112EL_HBRIDGE_9)
  {
    return TLE94112EL_HB_MODE_2_CTRL;
  }
  else if (hbridge < TLE94112EL_HBRIDGE_MAX)
  {
    return TLE94112EL_HB_MODE_3_CTRL;
  }
  else
  {
    return 0xff;
  }
}

static inline uint8_t get_hbridge_fw_address(uint8_t hbridge)
{
  if (hbridge < TLE94112EL_HBRIDGE_7)
  {
    return TLE94112EL_FW_OL_CTRL;
  }
  else if (hbridge < TLE94112EL_HBRIDGE_MAX)
  {
    return TLE94112EL_FW_CTRL;
  }
  else
  {
    return 0xff;
  }
}

static inline uint8_t get_hbridge_act_address(uint8_t hbridge)
{
  if (hbridge < TLE94112EL_HBRIDGE_5)
  {
    return TLE94112EL_HB_ACT_1_CTRL;
  }
  else if (hbridge < TLE94112EL_HBRIDGE_9)
  {
    return TLE94112EL_HB_ACT_2_CTRL;
  }
  else if (hbridge < TLE94112EL_HBRIDGE_MAX)
  {
    return TLE94112EL_HB_ACT_3_CTRL;
  }
  else
  {
    return 0xff;
  }
}

static inline bool is_valid_diag_reg(uint8_t addr)
{
  return ((addr == TLE94112EL_SYS_DIAG1) || (addr == TLE94112EL_SYS_DIAG2) ||
		  (addr == TLE94112EL_SYS_DIAG2) || (addr == TLE94112EL_SYS_DIAG3) ||
		  (addr == TLE94112EL_SYS_DIAG4) || (addr == TLE94112EL_SYS_DIAG5) ||
		  (addr == TLE94112EL_SYS_DIAG6) || (addr == TLE94112EL_SYS_DIAG7));
}

int32_t TLE94112EL_GetDeviceId(const TLE94112EL_t *const handler)
{
  uint8_t tx_data[2];
  uint8_t rx_data[2];

  tx_data[0] = TLE94112EL_CONFIG_CTRL;
  tx_data[1] = 0xff;
  handler->spi_transfer(tx_data, rx_data);

  if ((rx_data[0] & 0x80) != 0)
  {
	return -1;
  }

  return ((rx_data[1] & TLE94112EL_CONFIG_CTRL_DEV_ID_Msk) >> TLE94112EL_CONFIG_CTRL_DEV_ID_Pos);
}

int32_t TLE94112EL_GetStatus(const TLE94112EL_t *const handler, uint8_t addr)
{
  uint8_t tx_data[2];
  uint8_t rx_data[2];

  if (!is_valid_diag_reg(addr))
  {
	return -1;
  }

  tx_data[0] = addr;
  tx_data[1] = 0xff;
  handler->spi_transfer(tx_data, rx_data);

  if ((rx_data[0] & 0x80) != 0)
  {
	return -1;
  }

  return rx_data[1];
}

int32_t TLE94112EL_ClearStatus(const TLE94112EL_t *const handler, uint8_t addr)
{
  uint8_t tx_data[2];
  uint8_t rx_data[2];

  if (!is_valid_diag_reg(addr))
  {
	return -1;
  }

  tx_data[0] = addr | TLE94112EL_SPI_CLEAR;
  tx_data[1] = 0;
  handler->spi_transfer(tx_data, rx_data);

  return rx_data[0];
}

int32_t TLE94112EL_Enable(const TLE94112EL_t *const handler)
{
  handler->enable();
  return 0;
}

int32_t TLE94112EL_Disable(const TLE94112EL_t *const handler)
{
  handler->disable();
  return 0;
}

int32_t TLE94112EL_SetPwmFrequency(const TLE94112EL_t *const handler, TLE94112EL_PWM_CHANNEL_t channel, TLE94112EL_PWM_FREQ_t freq)
{
  if (channel >= TLE94112EL_PWM_CHANNEL_MAX)
  {
	return -1;
  }

  uint8_t tx_data[2];
  uint8_t rx_data[2];

  tx_data[0] = TLE94112EL_PWM_CH_FREQ_CTRL;
  tx_data[1] = 0xff;
  handler->spi_transfer(tx_data, rx_data);

  tx_data[0] |= TLE94112EL_SPI_WRITE;
  tx_data[1] = (rx_data[1] & (uint8_t)~(TLE94112EL_PWM_CH_FREQ_CTRL_PWM_CH_FREQ_Msk << (channel * TLE94112EL_PWM_CH_FREQ_CTRL_PWM_CH_FREQ_Size))) |
		       (freq << (channel * TLE94112EL_PWM_CH_FREQ_CTRL_PWM_CH_FREQ_Size));

  handler->spi_transfer(tx_data, rx_data);

  return rx_data[0];
}

int32_t TLE94112EL_SetPwmDutyCycle(const TLE94112EL_t *const handler, TLE94112EL_PWM_CHANNEL_t channel, uint8_t duty_cyle)
{
  if (channel >= TLE94112EL_PWM_CHANNEL_MAX)
  {
	return -1;
  }

  uint8_t tx_data[2];
  uint8_t rx_data[2];

  tx_data[0] = get_pwm_channel_dc_address(channel) | TLE94112EL_SPI_WRITE;
  tx_data[1] = duty_cyle;

  handler->spi_transfer(tx_data, rx_data);

  return rx_data[0];
}

int32_t TLE94112EL_GetRegister(const TLE94112EL_t *const handler, uint8_t reg_addr)
{
  uint8_t tx_data[2];
  uint8_t rx_data[2];

  tx_data[0] = reg_addr;
  tx_data[1] = 0xff;

  handler->spi_transfer(tx_data, rx_data);

  return rx_data[1];
}

int32_t TLE94112EL_SetRegister(const TLE94112EL_t *const handler, uint8_t reg_addr, uint8_t reg_val, uint8_t reg_mask)
{
  uint8_t tx_data[2];
  uint8_t rx_data[2];

  tx_data[0] = reg_addr;
  tx_data[1] = 0xff;

  handler->spi_transfer(tx_data, rx_data);

  tx_data[0] |= TLE94112EL_SPI_WRITE;
  tx_data[1] = (rx_data[1] & (uint8_t)~reg_mask) | reg_val;

  handler->spi_transfer(tx_data, rx_data);

  return rx_data[0];
}

int32_t TLE94112EL_SetHBrigeMode(const TLE94112EL_t *const handler, TLE94112EL_HBRIDGE_t hbridge, TLE94112EL_HBRIDGE_MODE_t mode)
{
  if (hbridge >= TLE94112EL_HBRIDGE_MAX)
  {
	return -1;
  }

  uint8_t tx_data[2];
  uint8_t rx_data[2];

  tx_data[0] = get_hbridge_mode_address(hbridge);
  tx_data[1] = 0xff;
  handler->spi_transfer(tx_data, rx_data);

  tx_data[0] |= TLE94112EL_SPI_WRITE;
  tx_data[1] = (rx_data[1] & (uint8_t)~(TLE94112EL_HB_MODE_CTRL_HB_MODE_Msk << ((hbridge % 4) * TLE94112EL_HB_MODE_CTRL_HB_MODE_Size))) |
		       (mode << ((hbridge % 4) * TLE94112EL_HB_MODE_CTRL_HB_MODE_Size));

  handler->spi_transfer(tx_data, rx_data);

  return rx_data[0];
}

int32_t TLE94112EL_SetHBrigeFreeWheeling(const TLE94112EL_t *const handler, TLE94112EL_HBRIDGE_t hbridge, bool enable_free_wheeling)
{
  if (hbridge >= TLE94112EL_HBRIDGE_MAX)
  {
	return -1;
  }

  uint8_t tx_data[2];
  uint8_t rx_data[2];

  tx_data[0] = get_hbridge_fw_address(hbridge);
  tx_data[1] = 0xff;
  handler->spi_transfer(tx_data, rx_data);

  tx_data[0] |= TLE94112EL_SPI_WRITE;
  tx_data[1] = (rx_data[1] & (uint8_t)~(1 << ((hbridge + 2) % 8))) |
               ((enable_free_wheeling ? 1 : 0) << ((hbridge + 2) % 8));

  handler->spi_transfer(tx_data, rx_data);

  return rx_data[0];
}


int32_t TLE94112EL_SetHBrigeOutput(const TLE94112EL_t *const handler, TLE94112EL_HBRIDGE_t hbridge, TLE94112EL_HBRIDGE_OUTPUT_t output)
{
  if (hbridge >= TLE94112EL_HBRIDGE_MAX)
  {
	return -1;
  }

  uint8_t tx_data[2];
  uint8_t rx_data[2];

  tx_data[0] = get_hbridge_act_address(hbridge);
  tx_data[1] = 0xff;
  handler->spi_transfer(tx_data, rx_data);

  tx_data[0] |= TLE94112EL_SPI_WRITE;
  tx_data[1] = (rx_data[1] & (uint8_t)~(TLE94112EL_HB_ACT_CTRL_HB_Msk << ((hbridge % 4) * TLE94112EL_HB_ACT_CTRL_HB_Size))) |
		       (output << ((hbridge % 4) * TLE94112EL_HB_ACT_CTRL_HB_Size));

  handler->spi_transfer(tx_data, rx_data);

  return rx_data[0];
}

